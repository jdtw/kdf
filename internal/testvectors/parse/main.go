package main

import (
	"bufio"
	"encoding/hex"
	"flag"
	"fmt"
	"io"
	"log"
	"os"
	"strings"
)

var (
	in  = flag.String("in", "", "Input file")
	out = flag.String("out", "", "Output file")
)

type testVector struct {
	name       string
	count      int
	secret     []byte
	fixedInput []byte
	output     []byte
}

func main() {
	flag.Parse()

	fin, err := os.Open(*in)
	if err != nil {
		log.Fatal(err)
	}

	fout, err := os.Create(*out)
	if err != nil {
		log.Fatal(err)
	}

	fmt.Fprintln(fout, `// Autogenerated by github.com/jdtw/kdf/internal/testvectors/parse; DO NOT EDIT
package `, os.Getenv("GOPACKAGE"), `

import (
	"crypto/sha256"
	"crypto/sha512"
	"hash"
)

// Vector contains a NIST test vector for the HMAC CTR KDF.
type Vector struct {
	Name       string
	Hash       func() hash.Hash
	Secret     []byte
	FixedInput []byte
	Output     []byte
}

// Vectors contains the NIST test vectors for the HMAC CTR KDF.
var Vectors = []Vector{`)
	for _, v := range parseTestVectors(fin) {
		fmt.Fprintf(
			fout,
			"{Name: \"%s_%02d\", Hash: %s, Secret: %#v, FixedInput: %#v, Output: %#v},\n",
			v.name,
			v.count,
			hashFn(v.name),
			v.secret,
			v.fixedInput,
			v.output)

	}
	fmt.Fprintln(fout, "}")
}

func hexDecode(s string) []byte {
	bs, err := hex.DecodeString(s)
	if err != nil {
		panic(err)
	}
	return bs
}

func hashFn(name string) string {
	switch name {
	case "HMAC_SHA224":
		return "sha256.New224"
	case "HMAC_SHA256":
		return "sha256.New"
	case "HMAC_SHA384":
		return "sha512.New384"
	case "HMAC_SHA512":
		return "sha512.New"
	default:
		log.Fatalf("Unknown hash %s", name)
		return ""
	}
}

func parseTestVectors(r io.Reader) []*testVector {
	scanner := bufio.NewScanner(r)
	vectors := []*testVector{}
	var prf string
	count := 0
	v := new(testVector)
	for scanner.Scan() {
		line := scanner.Text()
		if s, found := strings.CutPrefix(line, "[PRF="); found {
			prf = strings.TrimSuffix(s, "]")
			count = 0
			continue
		}
		key, val, found := strings.Cut(line, " = ")
		if !found {
			continue
		}
		switch key {
		case "KI":
			v.secret = hexDecode(val)
		case "FixedInputData":
			v.fixedInput = hexDecode(val)
		case "KO":
			v.output = hexDecode(val)
			v.name = prf
			v.count = count
			count++
			vectors = append(vectors, v)
			v = new(testVector)
		default:
			continue
		}
	}
	return vectors
}
